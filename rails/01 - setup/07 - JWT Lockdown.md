

### Step 1: Replace controller content
```
#### app/controllers/graphql_controller.rb

# Change `RailsApiSchema` below to match what you have in app/graphql/xx_schema.rb file, the class definition:

# frozen_string_literal: true

class GraphqlController < ApplicationController
  before_action :authenticate_user!, unless: -> { graphql_authentication_action? }

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    token = request.headers['Authorization']&.split(' ')&.last

    context = {
      current_user: set_current_user,
      jwt_token: token,
      jwt_payload: decode_jwt_payload(token)
    }

    result = DealSourcingApiSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  private

  def authenticate_user!
    token = request.headers['Authorization']&.split(' ')&.last
    unless token
      render json: error_structure('Unauthorized', 401), status: :unauthorized
      return
    end

    begin
      jwt_payload = decode_jwt_payload(token)
      @current_user = User.find(jwt_payload['sub'])
    rescue JWT::DecodeError
      render json: error_structure('Invalid token', 401), status: :unauthorized
    rescue ActiveRecord::RecordNotFound
      render json: error_structure('User not found', 401), status: :unauthorized
    end
  end

  def set_current_user
    token = request.headers['Authorization']&.split(' ')&.last
    return nil unless token

    begin
      jwt_payload = decode_jwt_payload(token)
      User.find(jwt_payload['sub'])
    rescue JWT::DecodeError, ActiveRecord::RecordNotFound
      nil
    end
  end

  def error_structure(error, status)
    {
      'data' => nil,
      'errors' => [error],
      'message' => error,
      'httpStatus' => status
    }
  end

  def decode_jwt_payload(token)
    JWT.decode(token, Rails.application.credentials.jwt_secret_key).first
  rescue JWT::DecodeError
    nil
  end

  def graphql_authentication_action?
    sign_up_query? || sign_in_query? || otp_query? || reset_password_query? || create_log?
  end

  def sign_up_query?
    params[:query]&.include?('signUp')
  end

  def create_log?
    params[:query]&.include?('createLog')
  end

  def sign_in_query?
    params[:query]&.include?('signIn')
  end

  def otp_query?
    params[:query]&.include?('otpRequest')
  end

  def reset_password_query?
    params[:query]&.include?('resetPassword')
  end

  def prepare_variables(variables_param)
    case variables_param
    when String
      if variables_param.present?
        JSON.parse(variables_param) || {}
      else
        {}
      end
    when Hash
      variables_param
    when ActionController::Parameters
      variables_param.to_unsafe_hash
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{variables_param}"
    end
  end

  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")
    render json: { error: { message: e.message, backtrace: e.backtrace }, data: {} }, status: 500
  end
end
```

### Step 2: Understanding changes to controller
```
# Differences from the code generated by a generator:

- `before_action :authenticate_user!, unless: -> { graphql_authentication_action? }`:
  - Adds a before_action callback to authenticate the user unless the request is for a specific authentication action (sign up or sign in).
  - Ensures that authentication is skipped for specific GraphQL actions that don't require the user to be authenticated.

- `context = { current_user: set_current_user, jwt_token: request.headers['Authorization']&.split(' ')&.last }`:
  - Adds `current_user` and `jwt_token` to the context used in GraphQL execution.
  - This context is passed to the GraphQL resolvers, allowing them to access the current user and JWT token.

- `authenticate_user!` method:
  - Custom method to authenticate the user using JWT. 
  - Decodes the token from the Authorization header and sets the current user.
  - Renders an unauthorized error if the token is invalid or the user is not found.

- `set_current_user` method:
  - Custom method to decode the JWT token and set the current user.
  - Returns `nil` if the token is invalid or the user is not found.
  - Used to set the current user in the GraphQL context.

- `graphql_authentication_action?`, `sign_up_query?`, and `sign_in_query?` methods:
  - Custom methods to check if the current query is for signing up or signing in.
  - These methods are used to determine whether to skip authentication for the current request.
  - Helps in conditionally applying authentication logic based on the type of GraphQL action.

- `prepare_variables` method:
  - Custom method to handle different types of variables input (String, Hash, ActionController::Parameters, nil).
  - Converts the input variables to a suitable format for GraphQL execution.
  - Ensures that variables are properly parsed and handled.

- `handle_error_in_development` method:
  - Custom error handling for development environment.
  - Logs the error message and backtrace.
  - Returns a detailed error message in the JSON response, useful for debugging during development.

# Questions:
# 1. What is the purpose of the `before_action :authenticate_user!, unless: -> { graphql_authentication_action? }` callback in the controller?
# 2. How does the `context` hash enhance the functionality of GraphQL resolvers with `current_user` and `jwt_token`?
# 3. What are the roles of the `authenticate_user!` and `set_current_user` methods in handling JWT authentication?
# 4. How do the `graphql_authentication_action?`, `sign_up_query?`, and `sign_in_query?` methods contribute to the authentication logic in GraphQL requests?

```

### Step 3: Replace Login Spec 

```
# Replace login spec with below

require 'rails_helper'

RSpec.describe "Auth::SignIn", type: :request do
  describe 'signIn mutation' do
    let(:user) { create(:user, password: 'Password@123') }
    
    let(:query) do
      <<~GQL
        mutation SignIn($email: String!, $password: String!) {
          signIn(input: {
            email: $email,
            password: $password
          }) {
            data {
              id
              fullName
              email
              telephone
            }
            errors
            message
            httpStatus
            token
          }
        }
      GQL
    end

    let(:variables) do
      {
        email: user.email,
        password: 'Password@123'
      }
    end

    it 'authenticates an existing user with valid credentials' do
      post graphql_path, params: { query: query, variables: variables }

      json = JSON.parse(response.body)
      data = json['data']['signIn']

      expect(data['errors']).to be_empty
      expect(data['message']).to eq('User signed in successfully')
      expect(data['httpStatus']).to eq(200)
      expect(data['data']['fullName']).to eq(user.full_name)
      expect(data['data']['email']).to eq(user.email)
      expect(data['data']['telephone']).to eq(user.telephone)
      expect(data['token']).to be_present
    end

    it 'returns authentication errors for invalid credentials' do
      invalid_variables = variables.merge(password: 'WrongPassword')

      post graphql_path, params: { query: query, variables: invalid_variables }

      json = JSON.parse(response.body)
      data = json['data']['signIn']

      expect(data['data']).to be_nil
      expect(data['message']).to eq('User sign in failed')
      expect(data['httpStatus']).to eq(401)
      expect(data['errors']).to include('Invalid email or password')
    end
  end
end

# Questions
# 1: What change did we make to the mutation query?
# 2: Why did we add `expect(data['token']).to be_present`?
# 3: Why should we expect this test case for fail?
# 4: How will be get it to pass?
# 3: Run this test: `rspec ./spec/requests/auth/sign_in_spec.rb`
```

### Step 4: Fix failing test

```
# app/graphql/mutations/user_mutations.rb

# In user_mutations replace SignIn class:

class SignIn < Mutations::BaseMutation
  # Define the input arguments for the mutation
  argument :email, String, required: true
  argument :password, String, required: true

  # Define the return types for the mutation
  field :data, Types::UserType, null: true
  field :errors, [String], null: true
  field :message, String, null: false
  field :http_status, Integer, null: false
  field :token, String, null: true # Add token field to return token

  def resolve(email:, password:)
    user = User.find_by(email: email)

    # Get user token
    token = Warden::JWTAuth::UserEncoder.new.call(user, :user, nil).first
    
    if user&.valid_password?(password)
      {
        data: user,
        errors: [],
        message: "User signed in successfully",
        http_status: 200, # OK
        token: token # Return token
      }
    else
      {
        data: nil,
        errors: ["Invalid email or password"],
        message: "User sign in failed",
        http_status: 401, # Unauthorized
        token: nil # Return nil
      }
    end
  end
end

# Run the spec:

rspec ./spec/requests/auth/sign_in_spec.rb

# Questions
# 1: Why changes did we make to this file?
# 2: Why did we add `field :token, String, null: true`?
# 3: How did we generate the token?
# 4: Why was the user object required in generating the token?
# 5: How did we make sure token is returned?
```

### Step 5: Update mutation query
```
# visit:
http://127.0.0.1:3000/graphiql

# Run the following mutation with added token:

mutation {
  signIn(input: {
    email: "john.updated@example.com",
    password: "PAssword@123"
  }) {
    data {
      id
      fullName
      email
      telephone
    }
    errors,
    message,
    httpStatus,
    token
  }
}

# Questions
# 1: Notice that a token is returned?
# 2: How will this token be used by frontend?
# 3: What is contained in this token?
```

### Step 6: Inspect Failing Update Spec
```
# Run this spec
rspec ./spec/requests/auth/update_user_spec.rb

# Questions:
# What is the failing test?
# How did locking down the backend affect this test?
# what do we need to do to fix the failing test?
```

### Fix Failing Update Spec
```
# Replace update_user_spec.rb content with:

require 'rails_helper'

RSpec.describe "Auth::UpdateUser", type: :request do
  describe 'updateUser mutation' do
    let(:user) { create(:user) }
    let(:token ) { generate_jwt_token(user) }
    
    let(:query) do
      <<~GQL
        mutation UpdateUser($id: ID!, $fullName: String!, $email: String!, $telephone: String!) {
          updateUser(input: {
            id: $id,
            fullName: $fullName,
            email: $email,
            telephone: $telephone
          }) {
            data {
              id
              fullName
              email
              telephone
            }
            errors
            message
            httpStatus
          }
        }
      GQL
    end

    let(:variables) do
      {
        id: user.id,
        fullName: 'John Updated',
        email: 'john.updated@example.com',
        telephone: '1234567890'
      }
    end

    let(:headers) do
      {
        'Authorization': "Bearer #{token}"
      }
    end

    it 'updates an existing user with valid input' do
      post graphql_path, params: { query: query, variables: variables }, headers: headers

      json = JSON.parse(response.body)
      data = json['data']['updateUser']

      expect(data['errors']).to be_empty
      expect(data['message']).to eq('User updated successfully')
      expect(data['httpStatus']).to eq(200)
      expect(data['data']['fullName']).to eq('John Updated')
      expect(data['data']['email']).to eq('john.updated@example.com')
      expect(data['data']['telephone']).to eq('1234567890')
    end

    it 'returns validation errors for invalid input' do
      invalid_variables = variables.merge(fullName: '', email: 'invalid email', telephone: 'invalid telephone')

      post graphql_path, params: { query: query, variables: invalid_variables }, headers: headers

      json = JSON.parse(response.body)
      data = json['data']['updateUser']

      expect(data['data']).to be_nil
      expect(data['message']).to eq('User update failed')
      expect(data['httpStatus']).to eq(422)
      expect(data['errors']).to include(
        "Email is invalid",
        "Full name can't be blank",
        "Full name is too short (minimum is 4 characters)",
        "Full name is invalid",
        "Telephone is not a number"
      )
    end
  end
end

# Questions:
# 1: What changes did we make to this file?
# 2: Based on this code, how is the token generated?
# 3: Where is the `generate_jwt_token` defined in your code base?
# 4: How did we define the headers?
# 5: What is contained in the headers? Why is that required?
# 6: How did we add the the headers to the post request?
```

### Run mutation query 
```
# visit:
http://127.0.0.1:3000/graphiql

# run this mutation, copy the token generated from your login from Step 5 above, add it to the
# headers section of graphql browser.

mutation {
  updateUser(input: {
    id: 1,
    fullName: "John Updated",
    email: "john.updated@example.com",
    telephone: "07545676788"
  }) {
    data {
      id
      fullName
      email
      telephone
    }
    message,
    errors,
    httpStatus
  }
}

# Update headers section:
{
  "Authorization": "Bearer paste-token-here"
}

# run
Now run the query mutation

# Questions:
# 1: Why did we make the request with token sent in the header?
# 2: What error will you see without the header being sent?
```